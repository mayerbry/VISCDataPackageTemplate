%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                    %
%  bama_qc_report.Rnw                                                %
%  by:   Paul Obrecht                                                %
%  date: 9/25/2017                                                   %
%                                                                    %
%  Knitr code for BAMA QC Report                                     %
%                                                                    %
%  Requires: qc_functions.R                                          %
%            qc_latexheaders.tex                                     %
%                                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\VignetteEngine{knitr::knitr_notangle}
%\VignetteIndexEntry{BAMA QC Report}

<<FuncOptLibSrc, echo=FALSE, message=FALSE>>=

# Libraries
library(devtools)
library(data.table)
library(knitr)
library(xtable)
library(ggplot2)

# Functions
source("qc_functions.R")
source("protocol_specific.R")
source("functions.R")

# Are these 'subjects' or 'participants'?
# PTIDtype <- "animal"
PTIDtype <- "Animal"
if(tolower(PTIDtype)=="animal"){
	partsubj <- "subject"
	Partsubj <- "Subject"
} else if(tolower(PTIDtype)=="human"){
	partsubj <- "participant"
	Partsubj <- "Participant"
} else {
	cat("\\textcolor{red}{PTIDtype must be set at the top of the code and must be either `Animal' or `Human'.}")
}

# Rversion, username, and protocol needed for footers and memo lines
# Ruser <- "pobrecht"
Ruser <- Sys.getenv("USER")
username <- getUsername(Ruser)
Rversion <- paste0("R version ", R.version$major, ".", R.version$minor, " (", username, ")")

# get protocol name
pkgName <- roxygen2:::read.description("../DESCRIPTION")$Package
pkgName1 <- simpleCap(gsub(".", " ", pkgName, fixed=TRUE)) # Remove dots from protocol name
pkgName1 <- gsub("([[:alpha:]])([[:digit:]])", "\\1 \\2", pkgName1) # space between VDC name and protocol number

# xtable print method options
options(xtable.floating=TRUE,
	      xtable.table.placement="htbp",
	      xtable.include.rownames=FALSE,
	      xtable.caption.placement="top",
				xtable.sanitize.colnames.function=bold.allcolheads,
				xtable.comment=TRUE,
	      xtable.size="\\small"
	      )

# R chunk options
opts_chunk$set(results = "asis", cache = FALSE, echo = FALSE, tidy = TRUE, message = FALSE, warning = FALSE, dev = c("pdf", "png"), dpi = 300, fig.pos = 'htbp', fig.height = 7, fig.width = 7, scipen=0, digits=2)

# Load serum bama dataset
ds <- paste0(pkgName, "_serum_bama")
load(paste0("../data/", ds, ".rda"))
ds1 <- copy(get(ds)) # make a working copy

# Subset to reported variabes, rename, and LateXify
ds1 <- ds1[, .(isotype, ptid, group, visitno, antigen, clade, ARP_panel, in_ARP_panel, refAntigen, dilution,
               pos_threshold, fi, fi_bkgd, stddev, n_repl, fi_bkgd_blank, n_repl_blank, delta, filter_reason, response)]

ds1[, Week := paste("Week", visitno)]

# vw_map <- data.table(
#   visitno = c(1, 4, 5, 6, 10),
#   Week = paste("Week", c(0, 4, 12, 20, 28))
# )
#
# ds1 <- merge(ds1, vw_map, by="visitno")

setnames(ds1, c("Isotype", Partsubj, "Group", "Visit", "Antigen", "Clade", "ARP Panel", "in APR panel", "Neg Ctrl Antigen",
								"Dilution", "Cutoff", "FI", "fi_bkgd", "Std Dev", "# of Replicates", "Neg Ctrl $\\textrm{FI}-\\textrm{bkgd}$",
								"n_repl_blank", "MFI", "Filter Reason", "Response" , "Week"))

ds1[, `:=`(Antigen = gsub("_", "\\_", Antigen, fixed=TRUE),
					 Clade = gsub("_", "\\_", Clade, fixed=TRUE),
					 `$\\mathrm{MFI}^{*}$` = formatCwrap(round(MFI, 1), 1, "f"),
					 `$\\mathrm{FI}-\\mathrm{bkgd}$` = formatCwrap(round(fi_bkgd, 1), 1, "f"))]

# Some counts for later use inline
Ns <- sapply(ds1, function(x){length(unique(x))})[c("Isotype", Partsubj, "Week", "Antigen")]
expObs <- Ns["Isotype"] * Ns["Antigen"] # expected # of obs per ptid per timepoint
names(expObs) <- NULL
IsotypeSP <- ifelse(Ns[["Isotype"]]==1, "isotype", "isotypes")
baseline_visit <- -2
@

\newcommand{\Rver}{\Sexpr{Rversion}}
\input{qc_latexheaders.tex} % read in LaTeX preamble (this depends on Rversion defined in line above)
\fancyhead[R]{Uberla 465 BAMA QC Report} % other headers defined in preamble, but this is doc specific

\begin{document}

%To and From Section
\thispagestyle{titlepage}
\begin{flushleft}
  \begin{tabbing}
    this line is to\= set up the tab stop \kill
    \textbf{Date:} \> \insertdate \\
    \textbf{To:} \> \tabfill{%
      \href{mailto:"Georgia Tomaras"<georgia.tomaras@duke.edu>}{Georgia Tomaras},
      \href{mailto:"Nicole Yates"<nicole.yates@duke.edu>}{Nicole Yates},
      \href{mailto:"Sheetal Sawant"<sheetal.sawant@duke.edu>}{Sheetal Sawant},
      \href{mailto:"Sahill Patel"<sahill.patel@duke.edu>}{Sahill Patel},
      \href{mailto:"David Beaumont"<david.beaumont@duke.edu>}{David Beaumont},
      \href{mailto:"Kelli Greene"<kelli.greene@dm.duke.edu>}{Kelli Greene},
      \href{mailto:"Hongmei Gao"<hongmei.gao@dm.duke.edu>}{Hongmei Gao}} \\
		\textbf{From:} \>
		\href{mailto:"\Sexpr{username}"<\Sexpr{Ruser}@fredhutch.org>?subject=\Sexpr{pkgName1}\%20Serum\%20BAMA\%20QC\%20Report}{\Sexpr{username}} \\
    \textbf{RE:} \> \Sexpr{pkgName1}: Serum BAMA QC Report \\
    \textbf{cc:} \> \tabfill{%
      \href{mailto:"Bryan Mayer"<bmayer@fredhutch.org>}{Bryan Mayer},
      \href{mailto:"Alicia Sato"<asato@fredhutch.org>}{Alicia Sato},
      \href{mailto:"Jimmy Fulp"<wfulp@fredhutch.org>}{Jimmy Fulp},
      \href{mailto:"Celia Eddy"<ceddy@fredhutch.org>}{Celia Eddy},
      \href{mailto:"Eva Chung"<eachung@fredhutch.org>}{Eva Chung},
      \href{mailto:"Michelle Chung"<mchung2@fredhutch.org>}{Michelle Chung},
      \href{mailto:"April Randhawa"<cavdstudies@scharp.org>}{April Randhawa}} \\
\end{tabbing}
\hrule
\end{flushleft}

\vspace{1cm}

\begin{abstract}
Quality Control (QC) report for the Binding Antibody Multiplex Assay (BAMA) data generated from the \Sexpr{pkgName1} study. The report includes data summaries, response magnitude plots, response rates, and a list of positive responders.
\end{abstract}

\tableofcontents
\listoftables
\listoffigures

\input{background}

\section{Data Profile}
<<detect_deficiencies, eval=TRUE, echo=FALSE>>=
j <- ds1[, .(V = sum(!is.na(`$\\mathrm{MFI}^{*}$`))), by=c("Isotype", "Antigen", eval(Partsubj), "Week")]
formula <- as.formula(paste(Partsubj, "~ Week"))
dp <- dcast.data.table(j, formula, value.var="V", fun.aggregate=length)
setkeyv(dp, Partsubj)

deficiencies <- unique(unlist(sapply(lapply(2:length(dp), function(x) dp[, x, with=FALSE] != expObs), which)))

if(length(deficiencies)>0) {
  endString <- ", with deviations from the expected record count highlighted in red"
} else {
  endString <- paste0(", which has the expected number of records for each ", partsubj, " at each visit")
}
@
Each sample is run in duplicate, along with duplicate measurements of plate-level background MFI and MFI of the negative control bead, which is either uncoupled (Blank) or coupled to an empty gp70 scaffold (MulVgp70 His6). MFI values are averaged across replicates. The plate-level background is subtracted from the antigen-specific MFI; the resulting quantity is referred to in this report as `$\mathrm{FI}-\mathrm{bkgd}$'. Each antigen is then matched to its corresponding blank by isotype, dilution, \Sexpr{partsubj} ID, visit, notebook number, lab filename, and well type. The background-subtracted MFI of the Blank or MulVgp70 His6 (for gp70 antigens) is subtracted from the antigen-specific background-subtracted MFI; the resulting quantity is referred to in this report as `$\mathrm{MFI}^{*}$'.

These data transformations and calculations are performed by the Atlas-upload tool, but the calculations contained in this report reflect values independently recalculated by SCHARP staff. All tables except the appendix describe the averaged data at the screening dilution. Details about the processing of the unaveraged replicates, blank matching, and titration series (if provided) can be found in the appendix.

The BAMA data from the \Sexpr{pkgName1} study reflect MFI measurements on \Sexpr{spellNum(Ns[[Partsubj]])} \Sexpr{partsubj}s for \Sexpr{spellNum(Ns[["Antigen"]])} antigens and \Sexpr{spellNum(Ns[["Isotype"]])} \Sexpr{IsotypeSP} (\Sexpr{englist(ds1, "Isotype")}) at \Sexpr{spellNum(Ns[["Week"]])} time points: \Sexpr{paste(unique(ds1$Week)[order(as.numeric(substr(unique(ds1$Week), 6, 8)))], collapse=", ")}. Based on the data dimensions, one would expect the data file to contain \Sexpr{spellNum(Ns[["Isotype"]])} \Sexpr{IsotypeSP} $\times$ \Sexpr{spellNum(Ns[["Antigen"]])} antigens $=$ \Sexpr{expObs} averaged records for each \Sexpr{partsubj} at each visit. Table~\ref{dp1} summarizes the record count in the file\Sexpr{endString}.

<<recordCount_characterizeDeficiencies, eval=TRUE>>=
nRowsP1 <- 53 # number of table rows on first page of longtable (lower because of section heading)
nRowsPS <- 53 # number of table rows on subsequent pages

dp <- cbind(dp[, !grep("Week", names(dp)), with=FALSE], as.data.table(lapply(dp[, grep("Week", names(dp)), with=FALSE], function(x){color(x, x == expObs | x == 0, "red")})))
orderedWeeks <- names(dp)[2:length(names(dp))][order(as.numeric(substr(names(dp)[2:length(names(dp))], 6, 10)))]
setcolorder(dp, c(Partsubj, orderedWeeks))

np <- logical(nrow(dp))
multipage <- nrow(dp) > nRowsP1
if(multipage){np[seq(from=nRowsP1+1, to=nrow(dp), by=nRowsPS)] <- TRUE} # row number of first row on each page

thisCaption <- paste0("MFI record count, by ", partsubj, " and time point")
xtab <- xtable(dp, caption=thisCaption, label="dp1", align="lcrr")

if(multipage){
	print(xtab, tabular.environment='longtable', floating=FALSE,
				add.to.row = list(pos = list(0, which(np)-1),
													command = c("\\hline\\endhead", "\\clearpage\n")),
				sanitize.text.function=identity)
} else {
	print(xtab, sanitize.text.function=identity)
}
@

<<deficiencies>>=
# to use in eval option of later R chunks for missing rows or extra rows (dups)
perfectFile <- setDT(expand.grid(sapply(unname(sapply(
	c(Partsubj, "Week", "Isotype", "Antigen"),
	function(x){which(x==names(ds1))})),
	function(x){unique(ds1[, x, with=FALSE])})))

# edit to remove unassayed timepoints from perfectFile
perfectFile <- merge(perfectFile, unique(ds1[, c(Partsubj, "Group"), with=FALSE]), by=Partsubj)
thisFile <- ds1[, .(Obs=.N), by=c(Partsubj, "Week", "Isotype", "Antigen")]

setkeyv(perfectFile, c(Partsubj, "Week", "Isotype", "Antigen"))
setkeyv(thisFile, c(Partsubj, "Week", "Isotype", "Antigen"))

moige <- merge(cbind(perfectFile, pF=rep(TRUE, nrow(perfectFile))),
							 cbind(thisFile, tF=rep(TRUE, nrow(thisFile))),
							 by=c(Partsubj, "Week", "Isotype", "Antigen"),
							 all=TRUE)

hasMissingRows <- moige[is.na(tF), 1:4, with=FALSE]
hasExtraRows <- moige[is.na(pF) | Obs > 1, c(1:4,6) , with=FALSE]

hasNAvalsL <- nrow(ds1[is.na(`$\\mathrm{MFI}^{*}$`)]) > 0
hasMissingRowsL <- nrow(hasMissingRows) > 0

# Do we show table of NA values, table of missing rows, neither, or both?
if(hasNAvalsL + hasMissingRowsL == 2){
	text <- "To clarify the nature of the deviations, Table~\\ref{NA} summarizes the observations present in the file that have null values for $\\mathrm{MFI}^{*}$, and Table~\\ref{MR} lists observations that are not present in the data file but would be expected based on the values of descriptive variables observed for all study partipants."
} else if(hasNAvalsL + hasMissingRowsL == 0){
	text <- ""
} else if(hasNAvalsL==TRUE){
	text <- "The deficiencies in this file are all cases of null values in the data; there are no cases of rows that are expected but not found. Table~\\ref{NA} summarizes the observations present in the file that have null values for $\\mathrm{MFI}^{*}$."
	}	else if(hasMissingRowsL==TRUE){
	text <- "The deficiencies in this file are all cases of rows that are not represented in the file. Table~\\ref{MR} lists observations that are not present in the data file but would be expected based on the values of descriptive variables observed for all study partipants."
}	else {
	text <- paste0("\\textit{\\textcolor{red}{This was not supposed to happen -- hasNAvalsL is ", hasNAvalsL, " and hasMissingRowsL is ", hasMissingRowsL, ".}}")
}
@

\Sexpr{text} % print text determined by logic above.

<<printNAvals, eval = hasNAvalsL>>=
# tables in this R chunk print only if rows are present but have NA values.
hasNAvals <- ds1[is.na(`$\\mathrm{MFI}^{*}$`), .(Obs=.N),
								 by=c(Partsubj, "Isotype", "Antigen", "Week")]
setkeyv(hasNAvals, c(Partsubj, "Isotype", "Antigen", "Week"))

thisCaption <- "Summary of records with missing $\\mathrm{MFI}^{*}$"
xtab <- xtable(hasNAvals, caption=thisCaption, label="NA", align="llclcr")

print(xtab, sanitize.text.function=identity)
@

<<printMissingRows, eval = hasMissingRowsL>>=
# tables in this R chunk print only if rows that are expected are not in the data set: use V = .N.

# Condense table: print one row if all antigens missing for a PTID at a visit
hmr <- hasMissingRows[, .N, c("Isotype", "Antigen", Partsubj, "Week")]
formula <- as.formula(paste("Isotype + Antigen +", Partsubj, "~ Week"))
hmr <- dcast(hmr, formula, value.var="N")
wks <- as.numeric(gsub("[[:alpha:]]", "", names(hmr)[names(hmr) %like% "Week"]))
setcolorder(hmr, c("Isotype", "Antigen", Partsubj, names(hmr)[names(hmr) %like% "Week"][order(wks)]))
setkeyv(hmr, c("Isotype", Partsubj, "Antigen"))

thisCaption <- paste0("Missing antigens by isotype, ", partsubj, " and week")
xtab <- xtable(hmr, caption=thisCaption, label="MR", align=paste0("llll", strrep("r", length(wks))))
print(xtab, sanitize.text.function=identity)
@

<<printDups, eval = (nrow(hasExtraRows)>0)>>=
# Text that prints conditionally
cat("Table~\\ref{dups} lists descriptors with multiple observations. \\par")

thisCaption <- "Duplicated observations"
xtab <- xtable(hasExtraRows, caption=thisCaption, label="dups", align="llcccr")
print(xtab, sanitize.text.function=identity, table.placement = "h")
@

\clearpage

\section{Response Call}

The standard three-part positivity definition is used to identify positive responses.
\begin{enumerate}
\item $\mathrm{MFI}^{*} \ge \max(100, {}$ 95th percentile of $\mathrm{MFI}^{*}$ of the baseline samples that meet inclusion criteria, by isotype and antigen)
\item $\mathrm{MFI}^{*} > 3 \times \mathrm{MFI}^{*}_\mathrm{baseline}$
\item $\mathrm{FI}-\mathrm{bkgd} > 3 \times (\mathrm{FI}-\mathrm{bkgd})_\mathrm{baseline}$
\end{enumerate}

Table \ref{tab:refAnt} presents a list of reference antigens for each of the differential binding antigens.

<<refAntigens>>=
refAnt <- ds1[, .(Antigen, `Neg Ctrl Antigen`)][!duplicated(ds1[, .(Antigen, `Neg Ctrl Antigen`)]) & !is.na(`Neg Ctrl Antigen`)]
setkey(refAnt, Antigen)

thisCaption <- "Differential binding antigens and corresponding reference antigens"
xtab <- xtable(refAnt, caption=thisCaption, label="tab:refAnt", align="lll")

print(xtab, sanitize.text.function=identity)
@

<<filtered>>=
  filt <- ds1[, .N, by=`Filter Reason`]
	if(nrow(filt)==1 & tolower(filt[1]$`Filter Reason`)=="not filtered"){
		filt_text <- paste("No records were filtered from the", pkgName1, "BAMA assay data.")
		makeFiltTable <- FALSE
	} else {
		filt_text <- paste("Table \\ref{tab:filt} presents a list of records that were filtered from the", pkgName1, "BAMA assay data.")
		makeFiltTable <- TRUE
	}
@

Records for a particular isotype/\Sexpr{partsubj}/antigen/visit combination are excluded if the $\textrm{FI} - \textrm{bkgd}$ value for the corresponding negative control is greater than 5000. Records are excluded for a particular isotype/\Sexpr{partsubj}/antigen combination at \emph{all} visits if any of the following occurs at baseline:

\begin{itemize}
\item{baseline $\textrm{FI} - \textrm{bkgd}$ value for the corresponding negative control is greater than 5000}
\item{baseline $\textrm{MFI}^*$ is missing}
%\item{baseline $\textrm{MFI}^* > 5000$}
\end{itemize}

\Sexpr{filt_text}

<<makeFilt, eval=makeFiltTable, echo=FALSE>>=
filtered <- ds1[tolower(`Filter Reason`) != "not filtered",
								c(Partsubj, "Week", "Antigen", "Neg Ctrl Antigen",
									"Neg Ctrl Antigen $\\textrm{FI}-\\textrm{bkgd}$", "Filter Reason"), with=FALSE]

filtered[, `Filter Reason` := "Neg Ctrl MFI > 5000"]

thisCaption <- "Filtered Records"
xtab <- xtable(filtered, caption=thisCaption, label="tab:filt", align="llllb{0.6in}b{0.6in}l")
print(xtab, sanitize.text.function=identity, size="\\footnotesize")
@

Table \ref{tab:ant} presents a list of antigens and the corresponding negative control antigen or blank bead for each, along with antigen-specific positivity thresholds and record counts.

<<antigens>>=
ant <- ds1[, .(Cutoff=unique(Cutoff), N=.N), by=.(Antigen, Clade, `ARP Panel`, `Neg Ctrl Antigen`)]
setkey(ant, `Neg Ctrl Antigen`, Antigen)

thisCaption <- "List of antigens, including negative control antigens, positivity thresholds, and record counts"
xtab <- xtable(ant, caption=thisCaption, label="tab:ant", align="lllllrr")

print(xtab, size="\\footnotesize", sanitize.text.function=identity)
@

\clearpage
<<BAMA_plots, eval=TRUE, cache=FALSE>>=
# consider an R chunk option to make fig height
# proportional to nrow (as would be calculated below in the facet wrap),
# so e.g. 48 antigens gets a full page but 5 antigens gets a couple of inches.

# unLaTeXify some vars for plots
ds2 <- copy(ds1)[, `:=`(Antigen = gsub("\\_", "_", Antigen, fixed=TRUE),
												Week = as.factor(substr(Week, 6, 10)),
												Response = ifelse(is.na(Response) & Visit==baseline_visit, 99, Response))]

ds2[, xpanel := ifelse(grepl("120", Antigen), "gp120",
                       ifelse(grepl("140", Antigen) | Antigen == "1086 Trimer", "gp140",
                              ifelse(grepl("V2", toupper(Antigen)), "V1V2", "other")))]

if(exists("plots")){rm(plots)}
plots <- list()
for(p in sort(unique(ds2$xpanel))[c(1, 2, 4, 3)]){
  plots[[p]] <- ggplot(data = ds2[Isotype=='IgG' & xpanel == p & `Filter Reason`=="Not Filtered"],
                       aes(x = Week, y = pmax(1, MFI), group = Week)) +
    geom_boxplot(data=ds2[Isotype=='IgG' & xpanel == p & Response==1], lwd=0.3, fill="white", colour="#5C5C5C", outlier.size = 0, outlier.colour=NA) +
    geom_jitter(width=0.3, height=0, aes(color=as.factor(Response))) +
    geom_hline(aes(yintercept = Cutoff), colour = "royalblue4", size = 0.3, alpha = 0.75) +
    facet_wrap(~ Antigen, scales='fixed', ncol=3) +
		scale_y_log10("MFI*", breaks=c(1, 10, 100, 1000, 10000, 10^(log10(10000)+0.5)),
									labels=c('1', '10', expression(10^2), expression(10^3), expression(10^4), expression(10^{4.5}))) +
#    scale_x_discrete(breaks=c(-2, 30), labels=c('-2', '30'), limits = c(05, 40)) +
    xlab('Week') + ylab('MFI*') +
    scale_color_manual(name = "", breaks = c(0, 1, 99),
                         labels = c("Non-responder", "Responder", "Baseline"), values = c("royalblue4", "red", "darkgray")) +
#   scale_colour_discrete(name=NULL, labels=c("Responder", "Non-responder", "Baseline")) +
    theme(legend.position='top',
          strip.text = element_text(size = 7, face = 'bold')) +
    labs(col='')
}

i <- 1
for(n in names(plots)){
  cat("\\begin{figure}")
  cat(paste("\\caption{IgG: $\\mathrm{MFI^{*}}$ by antigen and visit,", n, "antigens}\\break"))
  print(plots[[n]])
	cat(paste0("\\label{fig:", names(plots)[i], "}\n"))
cat("\\footnotesize The horizontal blue line in each plot represents the positivity threshold. Non-responders above the line fail to meet one or more of the other positivity criteria.")
  cat("\\end{figure}")
  i <- i+1
#  if(i %in% c(2, 4, 6)){cat("\\clearpage")}
}
@

\clearpage

\section{Response Rates}

<<response_rates, echo=FALSE, results="asis">>=
nRowsP1 <- 44 # number of table rows on first page of longtable (lower because of section heading)
nRowsPS <- 48 # number of table rows on subsequent pages

tab <- prtDT(ds1[Week != paste("Week", baseline_visit)], keyVars=c("Isotype", "Antigen", "Week"), resp="Response")

tab[, Week := as.integer(substr(Week, 6, 10))]
setkey(tab, Isotype, Antigen, Week)

# clean up for latex
tab$CI <- gsub("%", "\\%", tab$CI, fixed=TRUE)
tab$percent <- gsub("%", "\\%", tab$percent, fixed=TRUE)
setnames(tab, c("percent", "CI"), c("Response Rate", "95\\% CI"))
setkey(tab, "Isotype", "Antigen", "Week")

for(iso in unique(tab$Isotype)){

#	cat(paste0("\\subsection{", iso, " Response Rates}"))
	resprate <- tab[Isotype == iso][, c("Antigen", "Week", "Response Rate", "95\\% CI"), with=FALSE]
	setnames(resprate, "95\\% CI", "95\\% CI\\protect\\footnotemark")

	# vectors to identify first row of new value for each column (used to null out values and for strut)
	kA <- !duplicated(resprate[, "Antigen", with=FALSE])

	np <- logical(nrow(resprate))
	multipage <- nrow(resprate) > nRowsP1
	if(multipage){np[seq(from=nRowsP1+1, to=nrow(resprate), by=nRowsPS)] <- TRUE} # row number of 1st row on each page

	resprate <- resprate[, Antigen := ifelse(kA | np, Antigen, "")]

	xtab <- xtable(resprate, caption=paste0(iso, " Response Rates\\label{tabresprate", iso, "}"), align="lllrr")

	if(multipage){
		print(xtab, tabular.environment='longtable', floating=FALSE, caption.placement = "bottom",
					add.to.row = list(pos = list(0, which(np)-1, which(kA)[-1]-2),
														command = c(paste0("\\hline\n\\endhead\n",
																							 "\\hline\\multicolumn{",
																							 dim(xtab)[2],
																							 "}{r}{\\footnotesize Continued on next page}\n",
																							 "\\endfoot\n",
																							 "\\multicolumn{",
																							 dim(xtab)[2],
																							 "}{l}{\\footnotesize ${}^1$ 95\\% CI based on Wilson score interval.}\n",
																							 "\\endlastfoot\n"),
																				"\\clearpage\n",
																				"")),
					sanitize.text.function=identity)
	} else {
		print(xtab, table.placement="h", caption.placement = "bottom",
					sanitize.text.function=identity)
	}

}
@
\clearpage

\section{Positive Responses}

<<pos_responders, echo=FALSE, results="asis">>=
nRowsP1 <-62 # number of table rows on first page of longtable (lower because of section heading)
nRowsPS <- 65 # number of table rows on subsequent pages

tmp <- copy(ds1)
posresp <- copy(tmp)[, .(Response, Week, Cutoff, `$\\mathrm{MFI}^{*}$`, `$\\mathrm{FI}-\\mathrm{bkgd}$`, `$\\mathrm{MFI}^{*}_\\mathrm{bl}$` = get("$\\mathrm{MFI}^{*}$")[Week==paste("Week", baseline_visit)], `$(\\mathrm{FI}-\\mathrm{bkgd})_\\mathrm{bl}$` = get("$\\mathrm{FI}-\\mathrm{bkgd}$")[Week==paste("Week", baseline_visit)]), by=c(Partsubj, "Antigen")][Response == 1][, Response := NULL]

setcolorder(posresp, c(Partsubj, "Week", "Antigen", "Cutoff", "$\\mathrm{MFI}^{*}$",
                       "$\\mathrm{FI}-\\mathrm{bkgd}$", "$\\mathrm{MFI}^{*}_\\mathrm{bl}$",
                       "$(\\mathrm{FI}-\\mathrm{bkgd})_\\mathrm{bl}$"))
aln <- "llllrrrrr"

setkeyv(posresp, c(Partsubj, "Week", "Antigen"))

kP  <- !duplicated(posresp[, c(Partsubj), with=FALSE])
kW  <- !duplicated(posresp[, c(Partsubj, "Week"), with=FALSE])

np <- logical(nrow(posresp))
multipage <- nrow(posresp) > nRowsP1

# row number of first row on each page, only if this table spans multiple pages
if(multipage){np[seq(from=nRowsP1+1, to=nrow(posresp), by=nRowsPS)] <- TRUE}

expr <- parse(text = paste(eval(Partsubj), ":= ifelse(kP | np, get(Partsubj), '')"))
posresp <- posresp[, eval(expr)][, Week := ifelse(kW | np, Week, "")]

xtab <- xtable(posresp, caption="List of Positive Responders\\label{posresp}", align=aln)

if(multipage){
  print(xtab, tabular.environment='longtable', caption.placement = "bottom",
        floating=FALSE, size="\\scriptsize",
        add.to.row = list(pos = list(0, which(np)-1, which(kW)[-1]-2),
                          command = c(paste0("\\hline\n\\endhead\n",
                                             "\\hline\\multicolumn{",
                                             dim(xtab)[2],
                                             "}{r}{\\footnotesize Continued on next page}\n",
                                             "\\endfoot\n\\endlastfoot\n"),
                                      "\\clearpage\n",
                                      "\\B\ ")),
        sanitize.text.function=identity)
} else {
  print(xtab, table.placement="h", caption.placement = "bottom", size="\\scriptsize",
        sanitize.text.function=identity)
}
@

\section{Appendix: Data Processing Details}

<<rawDataChecks>>=
bamalist <- list()
for(q in bama_qfilenames){
	bamalist[[q]] <- fread(paste0("../inst/extdata/", q))[, sourcefile := q]
}

# rbind all qdata files into single data table, drop variables with NA for every obs
bama <- rbindlist(bamalist, use.names=TRUE, fill=TRUE)
rm(bamalist)

bama <- bama[ptid != "" & !grepl("detection", tolower(ptid)) & specrole == "Unknown" & averaged=="false"][,
	antigen := ifelse(tolower(antigen) %in% blanklist[["gp70"]], "gp70 control", antigen)]

# facts
numRawRecs <- nrow(bama)
numRawRecsAnt <- nrow(bama[! tolower(antigen) %in% unlist(blanklist)])
numRawRecsBlank <- nrow(bama[tolower(antigen) %in% unlist(blanklist)])

# checks

# (1) Any number of replicates other than 2?
nrepl <- bama[, .(recCnt=.N), by=.(isotype, dilution, ptid, visitno, antigen, sourcefile, type, notebook, filename)]
nrepl2 <- nrepl[, .N, by=recCnt]
non2Repl <- nrepl[recCnt != 2]
nNon2Repl <- nrow(non2Repl)
anyNon2Repl <- nNon2Repl > 0

if(anyNon2Repl){
	replText <- "\\textcolor{red}{Need to figure out this logic later. Summarize records where there are some number of replicates other than 2.}"
} else {
	replText <- paste0("All records---when paired by isotype, dilution, ", partsubj, " ID, visit, notebook number, lab filename, and well type---have two replicates; there are no exceptions.")
}

# (2) Blank matching (code from preprocess_bama.R)
antigenMatch <- function(x){
  alist <- setdiff(tolower(unique(bama$antigen)), tolower(unlist(blanklist)))
  if(x == "blank"){
    setdiff(alist, unlist(lapply(names(blanklist)[names(blanklist) != "blank"], antigenMatch)))
  } else {
    alist[grepl(x, alist)]
  }
}
aMatch <- sapply(names(blanklist), antigenMatch)
for(a in names(aMatch)){
  bama[tolower(bama$antigen) %in% aMatch[[a]], refAntigen := blanklist[[a]][1]]
}

bama[tolower(antigen) %in% unlist(blanklist), refAntigen := tolower(antigen)]

bmatch1 <- bama[, .(recCnt=.N), by=.(isotype, dilution, ptid, antigen, visitno, sourcefile, type, notebook, filename, refAntigen)][, antigen := gsub("_", "\\_", antigen, fixed=TRUE)]

blank <- copy(bmatch1)[tolower(antigen) %in% unlist(blanklist)]

setkey(bmatch1, isotype, dilution, ptid, visitno, sourcefile, type, notebook, filename, refAntigen)
setkey(blank, isotype, dilution, ptid, visitno, sourcefile, type, notebook, filename, refAntigen)

bmatch2 <- merge(bmatch1[!tolower(antigen) %in% unlist(blanklist)][, inAnt := TRUE],
								 blank[, `:=`(antigen = NULL, inBlank = TRUE)],
								 all=TRUE)

nobmatch <- bmatch2[is.na(inAnt) | is.na(inBlank)][,
	`:=`(recCnt = max(recCnt.x, recCnt.y, na.rm=TRUE),
			 recCnt.x = NULL, recCnt.y = NULL)]

orphanBlanks <- nobmatch[is.na(inAnt)]
nonRunMatchedAntigens <- nobmatch[is.na(inBlank)]

if(exists("vw_map")){orphanBlanks <- merge(orphanBlanks, vw_map, by="visitno")}

# (3) Any missing values?
missingMFI <- bama[is.na(fi_bkgd)]
nMissingMFI <- nrow(missingMFI)
anyMissingMFI <- nMissingMFI > 0

if(anyMissingMFI){
	missingMFIText <- "There are \\Sexpr{nMissingMFI} missing MFI values in the unaveraged data."
} else {
	missingMFIText <- "There are no records with missing or non-numeric MFI values."
}

# facts
numAvgRecsAnt <- nrow(bmatch1[!tolower(antigen) %in% unlist(blanklist)])
numAvgRecsBlank <- nrow(blank)
numOrphanBlanks <- nrow(orphanBlanks)
numNonRunMatchedAntigens <- nrow(nonRunMatchedAntigens)

if(numAvgRecsAnt == numRawRecsAnt/2 & numAvgRecsBlank == numRawRecsBlank/2){
	expText <- ", as would be expected"
} else {
	expText <- ""
}

if(numOrphanBlanks==0 & numNonRunMatchedAntigens==0){
	bmatchText <- ""
} else if(numOrphanBlanks>0 & numNonRunMatchedAntigens>0){
	bmatchText <- paste0("When matching MFI records to blank/negative control antigen records, the standard approach of requiring same-run matches between experimental antigens and their corresponding blanks (using notebook number and lab filename as identifiers) leaves ", formatCwrap(numOrphanBlanks, 0, "f"), " blanks without a matching antigen. Unmatched blanks are discarded from the data processing and are not reflected in the other sections of this report. Table~\\ref{orphanBlanks} summarizes the blanks that were discarded from processing. Conversely, the standard blank-matching approach leaves ", formatCwrap(numNonRunMatchedAntigens), " antigen records without run-matched blanks. Table~\\ref{nonRunMatchedAntigens} summarizes the records that could not be run-matched to a blank/negative control antigen record. For these records, a looser blank-matching algorithm was applied in which the blank is matched by isotype, dilution, ", partsubj, ", and visit but is not required to have been run on the same physical plate as the antigen. This can result in more than one possible match, which must be resolved manually.")
} else if(numOrphanBlanks>0){
	bmatchText <- paste0("When matching MFI records to blank/negative control antigen records, the standard approach of requiring same-run matches between experimental antigens and their corresponding blanks (using notebook number and lab filename as identifiers) allows unambiguous blank matching but leaves ", formatCwrap(numOrphanBlanks), " blanks without a matching antigen. Unmatched blanks are discarded from the data processing and are not reflected in the other sections of this report. Table~\\ref{orphanBlanks} summarizes the blanks that were discarded from processing.")
} else if(numNonRunMatchedAntigens>0){
	bmatchText <- paste0("When matching MFI records to blank/negative control antigen records, the standard approach of requiring same-run matches between experimental antigens and their corresponding blanks (using notebook number and lab filename as identifiers) leaves ", formatCwrap(numNonRunMatchedAntigens, 0, "f"), " antigen records without run-matched blanks. Table~\\ref{nonRunMatchedAntigens} summarizes the records that could not be run-matched to a blank/negative control antigen record. For these records, a looser blank-matching algorithm was applied in which the blank is matched by isotype, dilution, ", partsubj, ", and visit but is not required to have been run on the same physical plate as the antigen. This can result in more than one possible match, which must be resolved manually.")
}
@

The unaveraged BAMA data population, excluding standard concentration curve records and internal lab control records, consists of \Sexpr{formatCwrap(numRawRecs, 0, "f")} records, of which \Sexpr{formatCwrap(numRawRecsAnt, 0, "f")} contain antigen-specific MFI values, and \Sexpr{formatCwrap(numRawRecsBlank, 0, "f")} contain MFI values of blanks/negatigve control antigens. After averaging the two replicates per measurement, the data population consists of \Sexpr{formatCwrap(numAvgRecsAnt, 0, "f")} antigen-specific records and \Sexpr{formatCwrap(numAvgRecsBlank, 0, "f")} negative-control-antigen records\Sexpr{expText}.
\Sexpr{missingMFIText}
\Sexpr{replText}
\Sexpr{bmatchText}


<<OrphanBlanks, eval=numOrphanBlanks > 0>>=
thisCaption <- paste0("Dilutions at which unmatched blank records exist, by isotype, ", partsubj, ", negative control antigen, and visit.\\label{orphanBlanks}") # table \ref is not numbered correctly in the text unless I put the label in the caption here
xtab <- xtable(orphanBlanks2, caption=thisCaption,
							 align=paste0(c("lccl", rep("r", length(unique(grep("Week", names(orphanBlanks2)))))), collapse=""))

print(xtab, caption.width="6in", size = "\\footnotesize",
			sanitize.text.function=identity)
@

<<NonRunMatchedAntigens, eval=numNonRunMatchedAntigens > 0>>=
nRowsP1 <- 54 # number of table rows on first page of longtable (lower because of section heading)
nRowsPS <- 65 # number of table rows on subsequent pages

kI <- !duplicated(nonRunMatchedAntigens2[, "Isotype", with=FALSE])
kP <- !duplicated(nonRunMatchedAntigens2[, Partsubj, with=FALSE])
np <- logical(nrow(nonRunMatchedAntigens2))

multipage <- nrow(nonRunMatchedAntigens2) > nRowsP1
if(multipage){np[seq(from=nRowsP1+1, to=nrow(nonRunMatchedAntigens2), by=nRowsPS)] <- TRUE} # row number of first row on each page

nonRunMatchedAntigens2 <- nonRunMatchedAntigens2[, `:=`(
	Isotype = ifelse(kI | np, Isotype, ""),
	Subject = ifelse(kP | np, Subject, "")
)]

thisCaption <- paste0("\\small Dilutions at which non-run-matched antigen records exist, by isotype, ", partsubj, ", antigen, negative control antigen, and visit.")
xtab <- xtable(nonRunMatchedAntigens2, caption=thisCaption, label="nonRunMatchedAntigens",
	align=paste0(c("lccll", rep("r", length(unique(grep("Week", names(nonRunMatchedAntigens2)))))), collapse=""))

if(multipage){
	print(xtab, size="\\footnotesize", tabular.environment='longtable', floating=FALSE,
				add.to.row = list(pos = list(0, which(np)-1, which(kP)[-1]-2),
													command = c(paste0("\\hline\n\\endfirsthead\n",
																						 "\\multicolumn{",
																						 dim(xtab)[2],
																						 "}{l}{\\footnotesize Continued from previous page}\n\\\\ \\hline",
																						 paste(bold.allcolheads(names(xtab)), collapse=' & '),
																						 " \\\\ \n\\hline\n",
																						 "\\endhead",
																						 "\\hline\n\\multicolumn{",
																						 dim(xtab)[2],
																						 "}{r}{\\footnotesize Continued on next page}\n",
																						 "\\endfoot\n\\endlastfoot\n"),
																			"\\clearpage\n",
																			"\\B\ ")),
				caption.placement="top",
				sanitize.text.function=identity)
} else {
	print(xtab,
				add.to.row = list(pos = list(0, which(kP)[-1]-2),
													command = c("\\hline\\endhead", "\\B\ ")),
				sanitize.text.function=identity)
}
@

<<chosenBlanks, eval=TRUE>>=
#chosenBlanks <- data.table(
# 	Subject = c("T205", "T214", "T217", "T218"),
# 	Week = c("Week 14", "Week 26", "Week 26", "Week 26"),
# 	"Neg Ctrl Antigen" = c("Blank", "gp70 control", "Blank", "Blank"),
# 	Notebook = c("CAA 000011", "CAA 000032", "Average of CAA 000030 and CAA 000031", "CAA 000032"))

# thisCaption <- "Notebook numbers of negative control antigens selected for cases with non-run-matched negative control antigens"
# xtab <- xtable(chosenBlanks, caption=thisCaption, label="chosenBlanks", align="lccll")

# print(xtab, sanitize.text.function=identity)
@


<<titrText, eval=length(unique(bama$isotype))>1>>=
form <- data.table(ref = paste0("\\ref{titr", unique(bama$isotype), "}"))
refs <- englist(form, "ref", oxford=ifelse(nrow(form)>2, TRUE, FALSE))

if(length(unique(bama$isotype))==1){
	titrText <- paste0("Table ", refs, " summarizes the number of unique ", partsubj, "s, as well as the number of unaveraged records per ", partsubj, ", represented in the ", unique(bama$isotype), " data for each antigen, dilution, and time point.")
} else {
	titrText <- paste0("Tables ", refs, " summarize the number of unique ", partsubj, "s, as well as the number of unaveraged records per ", partsubj, ", represented in the data for each isotype, antigen, dilution, and time point.")
}
@

%\Sexpr{titrText}

<<titrationTable, eval=length(unique(bama$dilution)>1)>>=
# make titration/visit table(s)
for(iso in unique(bama$isotype)){

	nRowsP1 <- 52 # number of table rows on first page of longtable (lower because of section heading)
	nRowsPS <- 54 # number of table rows on subsequent pages

	titrations <- dcast.data.table(
		bama[!tolower(antigen) %in% unlist(blanklist), .(Antigen = gsub("_", "\\_", antigen, fixed=TRUE),
						 Dilution = dilution,
						 Week = paste("Wk", visitno),
						 recs = paste0(length(unique(ptid)), "/", color(round(.N/length(unique(ptid)), 2), .N/length(unique(ptid)) == 2, "red"))),
				 by=.(antigen, visitno, dilution)],
		Antigen + Dilution ~ Week,
		value.var="recs")

	setkey(titrations, Antigen, Dilution)

	cols <- setdiff(names(titrations), c("antigen", "dilution"))
	cols2 <- c(cols, "Total")

	# set NAs to 0
	titrations[, eval(cols) := lapply(.SD, NAto0), .SDcols=cols]
	titrations[, Dilution := formatCwrap(Dilution, 0, "f")]
	setcolorder(titrations, c("Antigen", "Dilution", paste("Wk", sort(unique(bama$visitno)))))

	# vectors to identify first row of new value for each column (used to null out values and for strut)
	kA <- !duplicated(titrations[, "Antigen", with=FALSE])
	np <- logical(nrow(titrations))
	multipage <- nrow(titrations) > nRowsP1
	if(multipage){np[seq(from=nRowsP1+1, to=nrow(titrations), by=nRowsPS)] <- TRUE} # row number of first row on each page

	titrations <- titrations[, Antigen := ifelse(kA | np, Antigen, "")]

	thisCaption <- paste0(iso, " ", partsubj, " count/unaveraged record count per ",
												  partsubj, ", by antigen, dilution, and visit")
	thisLabel <- paste0("titr", iso)
	xtab <- xtable(titrations, caption=thisCaption, label=thisLabel,
								 align = paste(c("lll", rep("r", ncol(titrations)-2)), collapse=""))

	if(multipage){
		print(xtab, tabular.environment='longtable', floating=FALSE, size="\\footnotesize",
					add.to.row = list(pos = list(0, which(np)-1, which(kA)[-1]-2),
														command = c(paste0("\\hline\n\\endfirsthead\n",
																							 "\\multicolumn{",
																							 dim(xtab)[2],
																							 "}{l}{\\footnotesize Continued from previous page}\n\\\\ \\hline",
																							 paste(bold.allcolheads(names(xtab)), collapse=' & '),
																							 " \\\\ \n\\hline\n",
																							 "\\endhead",
																							 "\\hline\n\\multicolumn{",
																							 dim(xtab)[2],
																							 "}{r}{\\footnotesize Continued on next page}\n",
																							 "\\endfoot\n\\endlastfoot\n"),
																				"\\clearpage\n",
																				"\\B\ ")),
					sanitize.text.function=identity)
	} else {
		print(xtab, add.to.row = list(pos = list(0, which(kA)[-1]-2),
																	command = c("\\hline\\endhead", "\\B\ ")),
					sanitize.text.function=identity)
	}
}
@

\section{Reproducibility Tables}
<<echo=FALSE, eval=TRUE>>=
path <- rmarkdown:::normalize_path("./reproducibility.R")
read_chunk(path)
@

<<repro, echo=FALSE, eval=TRUE>>=
<<reprotab>>
@

\label{LastPageOfBackMatter}~
\end{document}
